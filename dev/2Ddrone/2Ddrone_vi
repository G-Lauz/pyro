#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu May 18 12:30:17 2023

@author: alex
"""

import numpy as np

import matplotlib.pyplot as plt

from pyro.dynamic  import drone
from pyro.analysis import costfunction
# from pyro.planning import trajectoryoptimisation

from pyro.planning import dynamicprogramming 
from pyro.planning import discretizer

#############################################################################
     
class drone2Dcostfunction( costfunction.CostFunction ):
    """ 

    
    """
    
    ############################
    def __init__(self, obstacles ):
        
        costfunction.CostFunction.__init__(self)
        
        # dimensions
        self.n = 2
        self.m = 2

        # Quadratic cost weights
        self.Q = np.diag( np.ones(self.n)  )
        self.R = np.diag( np.ones(self.m)  )
        self.S = np.diag( np.zeros(self.n) )
        
        self.obstacles = obstacles
        
        self.d_tol  = 2.0
        self.nab    = 10.0
        self.buffer = 1.0
        
        self.xbar = np.array([0,0])
        
        self.is_vectorized = False
        
    
    ############################
    @classmethod
    def from_sys(cls, sys):
        """ From ContinuousDynamicSystem instance """
        
        instance = cls( sys.n , sys.m )
        
        return instance
    

    #############################
    def h(self, x , t = 0):
        """ Final cost function with zero value """
        
        dx = x - self.xbar
        
        if x.ndim == 1 :
            
            J_f = dx.T @ self.S @ dx 
            
            
        else:
            
            # Quadratic terminal cost
            J_f = np.diag( dx.T @ self.S @ dx )
        
        return J_f
    
    
    #############################
    def g(self, x, u, t):
        """ Quadratic additive cost """
        
        dx = x - self.xbar
        
        if x.ndim == 1 :
            
            dJ = dx.T @ self.Q @ dx  + u.T @ self.R @ u
            
            deltas    = self.obstacles - x
            
            distances = np.linalg.norm( deltas , axis = 1 ) - self.buffer
            
            distances[ distances < 0 ] = 0
            
            costs = self.nab * np.exp( - ( distances / self.d_tol ) ** 2 )
            
            dJ = dJ + costs.sum()
            
        else:
        
            dJ = np.diag( dx.T @ self.Q @ dx ) + np.diag( u.T @ self.R @ u )
            
            deltas    = self.obstacles.T[:,:,np.newaxis] - x[:,np.newaxis,:]
            
            distances = np.linalg.norm( deltas , axis = 1 ) - self.buffer
            
            distances[ distances < 0 ] = 0
            
            # d_min     = distances.min( axis = 0 )
            
            # costs     = self.nab * ( 1 / ( distances )  - 1. / self.d_tol ) ** 2
            # costs     = self.nab * ( 1 / d_min ) ** 2
            costs = self.nab * np.exp( - ( distances / self.d_tol ) ** 2 )
            
            # costs[ distances > self.d_tol ] = 0
            
            dJ = dJ + costs.sum( axis = 0 )
            
        
        return dJ

sys  = drone.SpeedControlledDrone2D()


obstacles = np.array([[ 0.  , 20. ] ,
                    [ 0.  , 25. ] ,
                    [ 0.  , 30. ] ,
                    [ 5.  , 20. ] ,
                    [ 5.  , 25. ] ,
                    [ 5.  , 30. ] ,
                    [ 10. , 20. ] ,
                    [ 10. , 25. ] ,
                    [ 10. , 30. ] ,
                    [ 2.5 , 35  ] ,
                    [ 7.5 , 35  ] ] )

sys.obstacles = obstacles

sys.x_ub = np.array([+20,+35])
sys.x_lb = np.array([-10,10])

sys.u_ub = np.array([+5,+5])
sys.u_lb = np.array([-5,-5])



cf = drone2Dcostfunction( obstacles )

cf.Q[0,0] =   1.0
cf.Q[1,1] =   1.0
cf.R[0,0] =   100.0
cf.R[1,1] =   100.0

cf.buffer = 1.0
cf.d_tol  = 1.0
cf.nab    = 5000.0

cf.xbar = np.array([0.0,15.0])


# sys.x_ub = np.array([+15,+35])
# sys.x_lb = np.array([-5,15])
# sys.u_ub = np.array([+2,+2])
# sys.u_lb = np.array([-2,-2])
# cf.d_tol  = 0.5
# cf.Q[0,0] = 5.0
# cf.Q[1,1] = 5.0
# # cf.xbar = np.array([0.0,22.0])
# cf.xbar = np.array([5.0,22.0])
# # cf.xbar = np.array([10.0,22.0])

cf.INF = 20000

# Discrete world 
grid_sys = discretizer.GridDynamicSystem( sys , [201,201] , [5,5] , dt = 0.1 )


# DP alg

dp = dynamicprogramming.DynamicProgrammingWithLookUpTable( grid_sys, cf)

# dp.solve_bellman_equation( tol = 0.1 )

dp.compute_steps( 400 , animate_cost2go= False )

dp.plot_cost2go_3D()

dp.plot_policy( k = 0 )
dp.plot_policy( k = 1 )


#asign controller
ctl    = dp.get_lookup_table_controller()
cl_sys = ctl + sys

# Simulation and animation
cl_sys.x0   = np.array([7.5,27.5])
cl_sys.x0   = np.array([5.0,32.0])
cl_sys.compute_trajectory( 10, 10001, 'euler')
cl_sys.plot_trajectory('xu')
cl_sys.plot_phase_plane_trajectory()
cl_sys.animate_simulation()



